<!doctype html>
<html>

    <head>

        <meta charset="utf-8">

        <meta name="viewport" content="initial-scale=1, maximum-scale=1">

        <title>WebVR Mini</title>

        <script src="https://cdn.polyfill.io/v2/polyfill.js?features=Promise|gated,fetch|gated"></script>

        <style>
/*
         #webvr-canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            left: 0;
            top: 0;
            margin: 0;
        }
*/

        </style>

    </head>

    <body>

        <header>

            <h1>WebVR Mini</h1>

        </header>

        <section>

            <canvas id="webvr-canvas" width="640" height="480" style="border:1px solid black;"></canvas>

        </section>

        <footer>

        </footer>

        <!--load our app bundle-->

        <script src="js/webvr-mini.js"></script>

        <!--vertex shader-->
        <script id="vertex" type="x-shader/x-vertex">

            attribute vec4 aPosition;

            varying vec4 vColor;

            void main(void) {

                vColor = vec4(aPosition.xyz / 2.0 + 0.5, 1.0);

                gl_Position = vec4(aPosition);

            }

        </script>

        <!--fragment shader-->
        <script id="fragment" type="x-shader/x-fragment">

            #ifdef GL_ES

                precision highp float;

            #endif

            //uniform vec4 uColor;

            varying vec4 vColor;

            void main(void) {

                //gl_FragColor = uColor;

                // convert from clipsapce (-1 <-> +1) to color space (0 -> 1).

                gl_FragColor = vColor;

            }

        </script>

        <!--MAIN PROGRAM-->

        <script>

            // for a square

            var vboCode = 
                [
                    -0.5, -0.5, 0.0,
                     0.5, -0.5, 0.0,
                     0.5,  0.5, 0.0,
                    -0.5,  0.5, 0.0
                ];

            // indices for the
            var iboCode = 
                [
                    0, 1, 2,
                    0, 2, 3
                ];

            console.log("window.vrmini" + vrmini );

            console.log(vrmini.util.isIFrame()); // if true, we're in the webpack server iframe

            // Set up a display.

            var webgl = window.webgl = vrmini.webgl;

            webgl.init( 'webvr-canvas' );

                // Load when the DOM is available.

            window.addEventListener( 'DOMContentLoaded', function () {

                if ( webgl.ready() ) {

                    var canvas = webgl.getCanvas();

                    var gl = webgl.getContext();

                        gl.enable( gl.DEPTH_TEST );

                    gl.enable( gl.CULL_FACE );

                    gl.enable( gl.BLEND );

                    gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

                    // Set the clear color.

                    gl.clearColor( 0.1, 0.1, 0.1, 1.0 );

                    // Attach the shaders.

                    var vs = webgl.createShaderFromTag( 'vertex' );

                    var fs = webgl.createShaderFromTag( 'fragment' );

                    // Create the program.

                    var program = webgl.createProgram( vs, fs );

                    console.log("PROGRAM:" + program)

                    // use the program
                    // TODO: STORE MULTIPLE PROGRAMS FOR SWITCHING

                    gl.useProgram( program );

                    // SET VALUES FOR VERTEX BUFFER OBJECT

                    // Get location of the position attribute in vertex shader. NOTE: getAttrib...

                    var aPosition = gl.getAttribLocation( program, 'aPosition' );

                    // Bind vertex buffer.

                    var vbo = webgl.createVBO( vboCode, gl.STATIC_DRAW );

                    // Tell the attribute how to get info out of the VBO.

                    gl.enableVertexAttribArray( aPosition );

                    // Give the attribute rules for pulling info out of the VBO.

                    gl.vertexAttribPointer(
                        aPosition, 
                        3,             // size (2d or 3d)
                        gl.FLOAT,      // type
                        false,         // don't normalize
                        0,             // 0 = move forward size * sizeof(type) each iteration to get the next position
                        0              // start at the beginning of the buffer
                    );

                    var vboLen = vboCode.length;

                    // Bind index buffer.

                    var ibo = webgl.createIBO( iboCode, gl.STATIC_DRAW );

                    var iboLen = iboCode.length;

                    // FRAGMENT SHADER UNIFORM

                    // Get location of color of fragment shader. NOTE: getUniform...

                    var uColor = gl.getUniformLocation( program, 'uColor' );

                    // Set shader to RGBA vector4 color value.

                    gl.uniform4fv( uColor, [ 0.5, 1.0, 0.3, 1.0 ] );

                    console.log('program ready.');

                    window.bob = document.getElementById('webvr-canvas');

                    // animation loop

                    function render () {

                        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );

                        gl.viewport( 0, 0, canvas.width, canvas.height );

                        gl.drawElements( gl.TRIANGLES, iboLen, gl.UNSIGNED_SHORT, 0 );

                        requestAnimationFrame( render );

                    }

                    // start the rendering

                    render();

                } else {

                    console.error( 'webgl rendering not supported by this browser.' );
                }

            }, 

            false ); // end of domready event 


        </script>

    </body>

</html>